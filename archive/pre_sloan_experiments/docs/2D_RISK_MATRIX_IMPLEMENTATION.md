# 2D Risk Matrix Implementation Plan

**Date**: December 13, 2025
**Status**: ‚úÖ **COMPLETE** - Two Doors Framework Implemented
**Priority**: High - Addresses Fundamental Model Limitation

---

## Executive Summary

The Trust Fall experiment revealed a critical insight: **The model correctly predicts Performance (outcomes), but we're trying to predict two different things in one dimension.**

**The Discovery**:
- **With gates**: 87.5% pass rate (14/16) - Hard-coded logic catches system merchants
- **Without gates**: 56.2% pass rate (9/16) - Model cannot learn system merchant patterns
- **Jordan Poole**: Returns to "King" status (97% star-level) when gates disabled - **he actually succeeded** (17 PPG, 62.7% TS in championship run)

**The Ground Truth Trap**: Training labels are based on **outcomes** (Poole = "King" because he succeeded), but we want to predict **portability** (Poole = "System Merchant" because his production isn't portable).

**The Solution**: **2D Risk Matrix** separating Performance (what happened) from Dependence (is it portable?).

---

## The Problem: Ground Truth Trap

### What We Discovered

**Jordan Poole (2021-22) Training Label**: "King (Resilient Star)" - RQ: 1.06, Dominance: 23.6

**Why This Matters**:
- Poole **actually succeeded** in 2021-22 (17 PPG, 62.7% TS, championship ring)
- The model correctly learns: "High usage + efficiency = success"
- But we want to flag him as a "System Merchant" (high dependence, not portable)

**The Conflict**:
- **Training Label**: Performance-based (what happened)
- **Our Goal**: Portability-based (is it real/portable?)

These are **orthogonal dimensions**. Forcing them into one prediction creates the Ground Truth Trap.

### Trust Fall Experiment Results

**Hypothesis**: Model should learn system merchant patterns from features.

**Results**:
- **With gates**: 87.5% pass rate ‚úÖ
- **Without gates**: 56.2% pass rate ‚ùå
- **Diagnosis**: Model cannot learn system merchant patterns from current features

**Key Finding**: The intelligence lives in hard-coded gates, not the model. This proves the necessity of the 2D framework.

---

## The Solution: 2D Risk Matrix

### Framework Overview

Instead of forcing everything into one archetype prediction, use a **2D Risk Matrix**:

**X-Axis: Performance Score** (Star-Level Potential)
- **Question**: "Will this player produce in playoffs?"
- **Source**: Current archetype prediction model
- **Output**: 0-100% (King + Bulldozer probability)
- **Training Data**: Objective outcomes (what actually happened)

**Y-Axis: Dependence Score** (System Dependence)
- **Question**: "Is this production portable/system-dependent?"
- **Source**: Quantitative proxies from box score/tracking data
- **Output**: 0-100% (higher = more dependent)
- **Training Data**: None needed - calculated from physics of the game

### The Four Quadrants

| Quadrant | Performance | Dependence | Example | GM Insight |
|----------|-------------|------------|---------|------------|
| **Franchise Cornerstone** | High (‚â•70%) | Low (<30%) | Luka, Jokiƒá | Max contract, build around |
| **Luxury Component** | High (‚â•70%) | High (‚â•70%) | Poole, Sabonis | Valuable in system, risky as #1 |
| **Depth** | Low (<30%) | Low (<30%) | Role players | Reliable but limited |
| **Avoid** | Low (<30%) | High (‚â•70%) | System merchants | Empty calories |

### The "Morey Pitch"

**Luka**: High Performance / Low Dependence = **Franchise Cornerstone** ‚Üí Max contract, build around  
**Poole**: High Performance / High Dependence = **Luxury Component** ‚Üí Valuable in system, **DO NOT MAX**

This acknowledges reality (Poole was good) while capturing nuance (Poole is risky).

---

## Implementation Plan

### Phase 1: Calculate Quantitative Dependence Score

**The Mathematical Definition**: "The Ratio of Ease"

A player is dependent if their production relies on:
1. **Assisted shots** (created by others)
2. **Open shots** (generated by system/gravity)
3. **Low self-creation volume** (can't create own offense)

**The Quantitative Proxy Formula**:

```
DEPENDENCE_SCORE = (
    ASSISTED_FGM_PCT * 0.40 +           # 40% of shots are assisted
    OPEN_SHOT_FREQUENCY * 0.35 +         # 35% are wide open (6+ feet)
    (1 - SELF_CREATED_USAGE_RATIO) * 0.25  # 25% can't create own offense
)
```

**Where each component is calculated from objective data**:

1. **ASSISTED_FGM_PCT**: From box score data
   - `ASSISTED_FGM / TOTAL_FGM`
   - Higher = more dependent on playmakers

2. **OPEN_SHOT_FREQUENCY**: From shot tracking data
   - `FGA_6_PLUS_FEET / TOTAL_FGA`
   - Higher = more dependent on system/gravity

3. **SELF_CREATED_USAGE_RATIO**: From play type data
   - `(ISO_FGA + PNR_HANDLER_FGA) / TOTAL_FGA`
   - Lower = can't create own offense

**Why This Works**:
- **No manual labeling needed** - calculated from objective data
- **No hindsight bias** - uses regular season data only
- **Physics-based** - measures how the player actually scores
- **Portable** - works for any player, any season

### Phase 2: Implement 2D Prediction Function

**New Function Structure**:

```python
def predict_with_risk_matrix(player_data, usage_level):
    """
    Returns both performance AND dependence scores.
    """
    # Dimension 1: Performance (existing model)
    performance_result = predict_archetype_at_usage(player_data, usage_level)
    performance_score = performance_result['star_level_potential']
    
    # Dimension 2: Dependence (new calculation)
    dependence_score = calculate_system_dependence(player_data)
    
    # Categorize into risk quadrants
    risk_category = categorize_risk(performance_score, dependence_score)
    
    return {
        'performance_score': performance_score,
        'dependence_score': dependence_score,
        'risk_category': risk_category,
        'archetype': performance_result['archetype'],  # Keep for compatibility
        'metadata': {
            'performance_details': performance_result,
            'dependence_details': dependence_details
        }
    }
```

**Risk Categorization**:
- **Franchise Cornerstone**: Performance ‚â•70% AND Dependence <30%
- **Luxury Component**: Performance ‚â•70% AND Dependence ‚â•70%
- **Depth**: Performance <30% AND Dependence <30%
- **Avoid**: Performance <30% AND Dependence ‚â•70%

### Phase 3: Validation & Refinement

**Test Cases**:

1. **Jordan Poole (2021-22)**:
   - Expected: High Performance (he succeeded) + High Dependence (system merchant)
   - Check: `ASSISTED_FGM_PCT`, `OPEN_SHOT_FREQUENCY`, `SELF_CREATED_RATIO`
   - Validation: All three should be high ‚Üí High Dependence Score

2. **Luka Donƒçiƒá (2023-24)**:
   - Expected: High Performance + Low Dependence (portable)
   - Check: Low assisted%, low open shot%, high self-creation
   - Validation: All three should be low ‚Üí Low Dependence Score

3. **Domantas Sabonis (2021-22)**:
   - Expected: High Performance + High Dependence (system-based rim pressure)
   - Check: High assisted rim shots, low self-creation
   - Validation: Should show high dependence despite high production

**Success Criteria**:
- Dependence scores align with known cases (Poole high, Luka low)
- No manual labeling needed - calculated from data
- Scores are explainable (can show which component drives the score)

---

## Key Principles

### 1. Check Labels First

Before building any features, inspect training labels. The most expensive mistake is building features to catch patterns that don't exist in your data.

**Quick Check**:
```python
import pandas as pd
df_labels = pd.read_csv('results/resilience_archetypes.csv')
poole = df_labels[(df_labels['PLAYER_NAME'] == 'Jordan Poole') & 
                  (df_labels['SEASON'] == '2021-22')]
print(poole[['PLAYER_NAME', 'SEASON', 'archetype', 'resilience_quotient', 'dominance_score']])
```

### 2. Acknowledge Reality

If a player succeeded, label them as succeeding. Don't inject hindsight bias. Instead, add a separate dimension that captures risk.

### 3. Separate Concerns

- **Performance = Outcomes** (what happened)
- **Dependence = Portability** (is it real/portable?)

These are orthogonal. Don't force them into one prediction.

### 4. Use Quantitative Proxies

Dependence is not a label; it's a measurable property of how a player scores. Calculate it from objective data, not expert opinion.

---

## Files to Create/Modify

### New Files

1. **`src/nba_data/scripts/calculate_dependence_score.py`**
   - Calculate Dependence Score from quantitative proxies
   - No training labels needed

2. **`src/nba_data/scripts/predict_with_risk_matrix.py`**
   - 2D prediction function
   - Combines Performance (existing model) + Dependence (new calculation)

### Modified Files

1. **`src/nba_data/scripts/predict_conditional_archetype.py`**
   - Add `calculate_system_dependence()` method
   - Add `predict_with_risk_matrix()` method

2. **`test_latent_star_cases.py`**
   - Update test cases to validate both dimensions
   - Old: "Poole should be <30% star-level" (wrong - he succeeded)
   - New: "Poole should be High Performance + High Dependence"

---

## Expected Outcomes

### Scientific Achievement

You've identified the boundary between:
- **Engineering**: Building a model that predicts outcomes (‚úÖ Done)
- **Science**: Understanding when outcomes reflect talent vs. context (üéØ In Progress)

This is a **scientific breakthrough**, not an engineering failure.

### Practical Outcome

GMs get actionable insights:
- **Luka**: "Franchise Cornerstone" ‚Üí Max contract, build around
- **Poole**: "Luxury Component" ‚Üí Valuable in system, risky as #1
- This acknowledges reality (Poole was good) while capturing nuance (Poole is risky)

---

## Implementation Status: ‚úÖ COMPLETE

**Completed** (December 5, 2025):
1. ‚úÖ **Dependence Score calculation** (Phase 1) - Implemented in `calculate_dependence_score.py`
2. ‚úÖ **2D prediction function** (Phase 2) - Implemented in `predict_conditional_archetype.py`
3. ‚úÖ **Validation on test cases** (Phase 3) - Test suite in `test_2d_risk_matrix.py`
4. ‚úÖ **Data-driven thresholds** - Calculated 33rd/66th percentiles (0.3570/0.4482)
5. ‚úÖ **Gate logic refinements** - High-Usage Immunity and High-Usage Creator Exemption

**Key Achievements**:
- ‚úÖ Luka Donƒçiƒá correctly identified as **Franchise Cornerstone** (96.87% Performance, 26.59% Dependence)
- ‚úÖ Jordan Poole correctly identified as **Luxury Component** (58.62% Performance, 51.42% Dependence)
- ‚úÖ Data-driven thresholds replace arbitrary 0.30/0.70 cutoffs
- ‚úÖ Fixed "Luka Performance Cap" showstopper with context-aware gate logic

**Files Created/Modified**:
- ‚úÖ `src/nba_data/scripts/calculate_dependence_score.py` - Dependence score calculation
- ‚úÖ `src/nba_data/scripts/predict_conditional_archetype.py` - Added `predict_with_risk_matrix()` and `calculate_system_dependence()`
- ‚úÖ `test_2d_risk_matrix.py` - Validation test suite
- ‚úÖ `calculate_dependence_thresholds.py` - Threshold calculation script
- ‚úÖ `results/dependence_thresholds.json` - Data-driven thresholds
- ‚úÖ `results/data_driven_thresholds_summary.md` - Implementation summary
- ‚úÖ `results/luka_gate_fix_summary.md` - Gate logic fixes

**See**: `results/data_driven_thresholds_summary.md` for complete implementation details.

---

## References

- **Trust Fall Experiment**: `results/latent_star_test_cases_report_trust_fall.md`
- **Ground Truth Trap Discovery**: See post-mortem insights in implementation plan
- **Current Model**: `CURRENT_STATE.md`
- **Key Insights**: `KEY_INSIGHTS.md` (see Insight #37: Trust Fall & Ground Truth Trap)


"""
Two-head training: performance (archetype) + portability (high/medium/low).

Portability labels are generated by generate_portability_labels.py and stored in
results/portability_labels.csv.

Split: temporal (train <=2020 seasons, test >2020).
Models:
- Performance head: XGB multi-class (same feature prep as Phoenix RFE 15 + FP interactions).
- Portability head: XGB multi-class on portability classes.

Outputs: metrics for both heads; no gating applied.
"""

import sys
from pathlib import Path
import pandas as pd
import xgboost as xgb
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

sys.path.insert(0, str(Path(__file__).parent))
from train_rfe_model import RFEModelTrainer  # noqa: E402


def parse_year(season_str):
    try:
        return int(season_str.split("-")[0]) if isinstance(season_str, str) else 0
    except Exception:
        return 0


def load_portability_labels(root: Path):
    path = root / "results" / "portability_labels_v2.csv"
    df = pd.read_csv(path)
    return df[["PLAYER_NAME", "SEASON", "PORTABILITY_CLASS", "PORTABILITY_SCORE"]]


def main():
    root = Path(__file__).resolve().parents[3]
    trainer = RFEModelTrainer()

    # Base Phoenix features + FP interactions
    base_feats = trainer.load_rfe_features(n_features=15, add_dependence_feats=True)
    extra_feats = [
        "USG_PCT_X_RS_OPEN_SHOT_FREQUENCY",
        "RIM_PRESSURE_DEFICIT",
        "USG_PCT_X_RIM_PRESSURE_DEFICIT",
    ]
    requested = list(dict.fromkeys(base_feats + extra_feats))

    df = trainer.load_and_merge_data()
    # Merge portability labels
    port_df = load_portability_labels(root)
    df = pd.merge(df, port_df, on=["PLAYER_NAME", "SEASON"], how="inner")

    X, feature_names = trainer.prepare_features(df, requested, add_dependence_feats=True)
    y_perf = df["ARCHETYPE"]
    y_port = df["PORTABILITY_CLASS"]

    df["_SEASON_YEAR"] = df["SEASON"].apply(parse_year)
    train_mask = df["_SEASON_YEAR"] <= 2020
    test_mask = df["_SEASON_YEAR"] > 2020

    X_train = X.loc[train_mask].fillna(0)
    X_test = X.loc[test_mask].fillna(0)

    # Performance head
    le_perf = LabelEncoder()
    y_perf_enc = le_perf.fit_transform(y_perf)
    y_perf_train = y_perf_enc[train_mask]
    y_perf_test = y_perf_enc[test_mask]
    y_perf_test_raw = y_perf[test_mask]

    # Portability head
    le_port = LabelEncoder()
    y_port_enc = le_port.fit_transform(y_port)
    y_port_train = y_port_enc[train_mask]
    y_port_test = y_port_enc[test_mask]
    y_port_test_raw = y_port[test_mask]

    # Shared monotone constraints
    mono_map = {
        "TS_PCT_VS_USAGE_BAND_EXPECTATION": 1,
        "USG_PCT": 1,
        "USG_PCT_X_TS_PCT_VS_USAGE_BAND_EXPECTATION": 1,
        "USG_PCT_X_RS_PRESSURE_APPETITE": 1,
        "USG_PCT_X_RS_LATE_CLOCK_PRESSURE_RESILIENCE": 1,
        "USG_PCT_X_EFG_ISO_WEIGHTED": 1,
        "PREV_EFG_ISO_WEIGHTED": 1,
        "PREV_RS_RIM_APPETITE": 1,
        "SKILL_MATURITY_INDEX": 1,
        "USG_PCT_X_INEFFICIENT_VOLUME_SCORE": -1,
        "CLUTCH_X_TS_FLOOR_GAP": -1,
        "USG_PCT_X_TS_FLOOR_GAP": -1,
        "TS_FLOOR_GAP": -1,
        "USG_PCT_X_RS_OPEN_SHOT_FREQUENCY": -1,
        "RIM_PRESSURE_DEFICIT": -1,
        "USG_PCT_X_RIM_PRESSURE_DEFICIT": -1,
    }
    monos = [mono_map.get(f, 0) for f in feature_names]

    def make_model(num_classes):
        return xgb.XGBClassifier(
            objective="multi:softprob",
            num_class=num_classes,
            n_estimators=300,
            max_depth=5,
            learning_rate=0.08,
            subsample=0.9,
            colsample_bytree=0.9,
            eval_metric="mlogloss",
            random_state=42,
            monotone_constraints=tuple(monos),
        )

    # Train performance head
    perf_model = make_model(len(le_perf.classes_))
    perf_model.fit(X_train, y_perf_train)
    y_perf_pred = perf_model.predict(X_test)
    perf_acc = accuracy_score(y_perf_test, y_perf_pred)
    perf_cm = confusion_matrix(y_perf_test, y_perf_pred)
    perf_report = classification_report(
        y_perf_test, y_perf_pred, target_names=le_perf.classes_, digits=3
    )

    # Train portability head
    port_model = make_model(len(le_port.classes_))
    port_model.fit(X_train, y_port_train)
    y_port_pred = port_model.predict(X_test)
    port_acc = accuracy_score(y_port_test, y_port_pred)
    port_cm = confusion_matrix(y_port_test, y_port_pred)
    port_report = classification_report(
        y_port_test, y_port_pred, target_names=le_port.classes_, digits=3
    )

    print("Performance head (archetype) metrics")
    print(f"Accuracy: {perf_acc:.4f}")
    print("Confusion matrix (rows=true, cols=pred):")
    print(perf_cm)
    print(perf_report)

    print("\nPortability head (high/medium/low) metrics")
    print(f"Accuracy: {port_acc:.4f}")
    print("Confusion matrix (rows=true, cols=pred):")
    print(port_cm)
    print(port_report)


if __name__ == "__main__":
    main()
